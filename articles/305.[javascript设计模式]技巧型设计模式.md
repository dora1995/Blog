### 一、介绍
> 技巧型设计模式是通过一些特定技巧来解决组件的某些方面的问题，这类技巧一般是通过实践经验总结得到的

- 链模式
- 委托模式
- 数据访问对象模式
- 节流模式
- 简单模板模式
- 惰性模式
- 参与者模式
- 等待者模式

### 二、链式模式
通过在对象方法中将当前对象返回，实现对同一个对象多个方法的链式调用。从而简化在要对该对象的方法多次调用时，减少对该对象的多次引用

链式模式是基于原型继承的，并且在每一个原型方法的实现上都返回当前对象this

JQ实现的源码解析，原型指向，强化构造器constructor，首次加载初始化需要根据环境变化的参数减少往后使用的开销

链式模式可以提高功能的开发效率，使其逻辑过程紧凑简洁

### 三、委托模式
委托模式是多个对象接受并处理同一个请求，他们将请求委托给另一个对象同意处理请求

当有多个对象需要对同一件事情做出相同操作时（都监听同一个事件与对应操作），如果循环绑定事件，会导致增加了很多事件监听与内存，影响页面性能，这时候可以使用委托模式

事件委托：事件流是从事件捕获开始，到事件触发，再到事件冒泡三个过程，所以可以将子元素的事件委托给更高层的父元素去绑定执行

这样，就可以做到只监听父元素事件，完成对子元素的操作管理了。统一事件的分发

### 四、数据访问对象模式
数据访问对象模式是抽象和封装对数据源的访问与存储，DAO通过对数据源链接的管理方便对数据的访问的存储

也就是把对于“数据库”的访问等操作封装起来，形成对前端储存的管理

主要运用在node对数据操作的封装

### 五、节流模式
防抖动函数：对重复的业务逻辑进行节流控制，执行最后一次操作并取消其他操作提供性能
节流函数：一个时间段内只执行一次操作，其他重复的将会被取消

节流模式跟上面提到的两个函数概念不同，但实现是一样的。节流模式主要目的是减少某些操作的重复触发或减少无意行为，从而节省资源，其核心思想是创建计时器来延迟程序的执行

### 六、简单模板模式
通过格式化字符串拼出视图避免创建视图时大量节点操作，优化内存开销

最后通过dom.innerHTML、dom.appendChild 一次性插入

简单模板模式意在解决运用DOM操作创建视图时造成的资源消耗过大、性能低下、操作重复等问题。主要包含三部分：字符串模板库，格式化方法，字符串拼接操作，其中模板库是多变的，可以根据需求的不同变化，从而实现灵活的运用

主要运用于频繁的dom操作上

### 七、惰性模式
惰性模式主要是减少每次代码执行时的重复性的分支判断，通过对对象重定义来屏蔽原对象中的分支判断

在相同环境下，其实很多对能力检测的操作只需要执行一次

有两种实现方式：第一种是在文件加载时通过闭包执行该方法对其重新定义（页面加载时会占用一定资源），第二种是在第一种方式的基础上做一次延迟，在函数第一次调用的时候对其重新定义（在第一次执行时有一定资源消耗）

```javascript
// 第一种
A.on = function (dom, type, fn) {
    if (document.addEventListener) {
        return function (dom, type, fn) {
            dom.addEventListener(type, fn, false)
        }
    } else if (document.attachEvent) {
        return function (dom, type, fn) {
            dom.attachEvent('on' + type, fn)
        }
    } else {
        return function (dom, type, fn) {
            dom['on' + type] = fn
        }
    }
}()

// 第二种
A.on = function (dom, type, fn) {
    if (document.addEventListener) {
        A.on = function (dom, type, fn) {
            dom.addEventListener(type, fn, false)
        }
    } else if (document.attachEvent) {
        A.on = function (dom, type, fn) {
            dom.attachEvent('on' + type, fn)
        }
    } else {
        A.on = function (dom, type, fn) {
            dom['on' + type] = fn
        }
    }
    A.on(dom, type, fn)
}()
```

主要运用在兼容方面

### 八、参与者模式
在特定的作用域中执行给定的函数，并将参数原封不动地传递

主要核心是bind函数的使用

函数柯里化思想：将接受多个参数的函数转化为接受一部分参数的新函数，余下的参数保存下来，当函数调用时，返回传入的参数与保持的参数共同执行的结果，通常保存下来的参数保存于闭包内，需要消耗一定资源

### 九、等待者模式
通过对多个异步进程监听，来触发未来发生的动作，用来解决那些不确定先后完成的异步逻辑

等待者模式为我们提供了一个抽象的非阻塞的解决方案，通过创建promise，对耗时逻辑的未来状态变化返回一个响应，通过内部返回的状态判断对应要完成的操作

promise源码实现、计步器


### 十、总结
技巧型设计模式都是一些平时开发中会用到的，然后总结出来的思维模式

在很多情况下其实我们有在用着它们：jq的链式调用、dom事件委托、数据库访问封装、节流与防抖动函数、编写html字符串模板提高性能、promise或计步器的使用等等，从而解决相对应的问题
