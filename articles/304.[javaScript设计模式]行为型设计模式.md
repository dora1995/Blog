### 一、介绍
> 行为型设计模式用于不同对象之间职责划分或算法抽象，不仅仅涉及类和对象，还涉及类或对象之间的交流模式并加以实现

- 模板方法模式
- 观察者模式
- 状态模式
- 策略模式
- 职责链模式
- 命令模式
- 访问者模式
- 中介者模式
- 备忘录模式
- 迭代器模式
- 解释器模式

### 二、模板方法模式
父类中定义一组操作算法骨架，而将一些实现步骤延迟到子类中，使得子类可以不改变父类的算法结构的同事可重新定义算法中某些实现步骤

比如有一个提示框父类，其子类有多种样式的提示框子类。在父类中定义通用的属性与方法，即一个框架（如一个蛋糕的蛋糕胚），然后子类通过继承该父类，并对父类的属性方法或逻辑进行修改从而达到多样化的目的（覆盖在蛋糕胚外的奶油、不同形状的样式）

### 三、观察者模式（发布订阅者模式、消息机制）
观察者模式又叫作发布-订阅者模式或消息机制，其中定义了一种依赖关系，**解决了主体对象与观察者之间功能的耦合**

好比幼儿园的一个班，家长委托老师帮忙看一下孩子，如果孩子做了某件事，老师就告诉家长一声。如果家长没有交代，那对应的孩子就不需要留意

那么老师就是观察者，孩子是被观察者，家长是订阅者

观察者有1.特别注意孩子做事的信息（订阅消息） 2.告诉家长（发送订阅）方法，同时还有3.不需要看着了（取消订阅）

```javascript
var Observer = (function () {
    var _message = {}
    return {
        // 注册方法的作用是将订阅者注册的消息推入到消息队列中
        regist: function (type, fn) {
            if (_message[type] === 'undefined') {
                _message[type] = [fn]
            } else {
                _message[type].push(fn)
            }
        },
        // 发送订阅的作用是当观察者发布一个消息时，会将对应的所有订阅者的信息都执行
        fire: function (type, args) {
            if (!_message[type]) {
                return
            }
            for(var i = 0; i < _message[type].length; i++) {
                _message[type][i].call(this, args || {})
            }
        },
        // 移除方法的作用是将订阅者从某类型中注销
        remove: function () {
            if (_message[type] instanceof Array) {
                var len = _message[type].length - 1
                for (; len >= 0; len--) {
                    _message[type][i] === fn && _message[type].splice(i, 1)
                }
            }
        }
    }
})()
```
比如家长让老师帮忙注意小A有没有打瞌睡，有的话就通知家长做一套军体拳：
```javascript
// 家长的方法里
Observer.regist('sleep', dosomething)
```

一旦孩子打瞌睡，就会触发
```javascript
// 孩子的方法里
Observer.fire('sleep', {msg: '我在睡觉'})
```
这样的话，家长和孩子之间的关系就解耦出来了，大家各司其职、不需要知道对方的存在。家长可以是爸爸妈妈爷爷奶奶等等多种角色，反正孩子一睡觉就触发订阅，不用管是告诉谁，因为通知谁的操作，老师（观察者）做了

观察者模式最主要的是解决类或对象之间的耦合，解除两个相互依赖的对象，从而由观察者统一关系网进行管理

### 四、状态模式
状态模式是当**一个对象的内部状态**发生改变时，会导致其行为的改变，从而改变结果

比如一个方法可以输入A/B/C三种选项，那么一般会对应写出
```javascript
function result(data) {
    dosomething...
    if (data == 'A') {
        ...
    } else if (data == 'B') {
        ...
    } else if (data == 'C') {
        ...
    }
    dosomething...
}
```
如果哪天又有一个新的选项D，则又要新增if语句来进行判断，这时候我们可以将这些选项作为函数里面的一个状态，在面对不同的判断结果时，做出相应的操作
```javascript
function result(data) {
    dosomething...
    var _status = {
        A: function () {},
        B: function () {},
        C: function () {},
        D: function () {},
    }
    dosomething...
    _status[type] && _status[type]()
}
```
这样新增逻辑的话，只要对应加上操作就可以了，不需要再做判断，将每一种状态都单独管理，解决分支之间的耦合问题。主要是解决对象内部程序中臃肿的分支判断语句问题，简化流程

### 五、策略模式
将定义的一组算法封装起来，使其相互之间可以替换。封装的算法具有一定独立性，不会随着客户端的变化而变化

从结构上看，它与状态模式很像，也是在内部封装一个对象然后通过返回的接口对象实现对内部对象的调用。不同的是，**策略模式不需要管理状态、状态之间没有依赖关系、策略之间可以相互替换、在策略对象内部保存的是相互独立的一些算法**：对于一件事的处理有多种方式，可以随意切换来达到不同的效果，状态模式是针对某一个对象内部的，而策略模式是针对某一种情况的

比如超市商品促销，圣诞节时候有些商品打五折，有些商品打八折，到了春节，普通用户满100减30，有些商品打七折，vip用户满100减40等等。如果为那么多商品都实现对应的类且设计返回对应价格的方式的话，会很大工程，我们可以为这些情况写一个策略：
```javascript
function priceReture = function() {
    var _stragtegy = {
        parcent5: function (price) {
            return price / 10 * 5
        },
        parcent7: function (price) {
            return price / 10 * 7
        },
        parcent8: function (price) {
            return price / 10 * 8
        },
        reduce30: function (price) {
            return price >= 100 ? price - 30 : price
        },
        reduce40: function (price) {
            return price >= 100 ? price - 40 : price
        },
    }
    return function(type, price) {
        return __stragtegy[type] && _stragtegy[type](price)
    }
}
```
这样，想要知道某个商品的活动价格或结算价格，只需要`var price = priceReture('parcent8', 100)`便可知道

策略模式使我们在外部看不到算法的具体实现，只需在意结果。使得算法脱离于模块逻辑而独立管理

### 六、职责链模式
职责链模式主要是解决请求的发送至与请求的接受者之间的耦合，通过职责链上的多个对象对分解请求流程，实现请求在多个对象之间的传递，最终完成请求的处理

分解需求，将整个需求模块化、颗粒化，把一件事件提取成多个可以互相独立的部分，最后再通过顺序调用的方式完成功能。对单元测试友好

### 七、命令模式
命令模式是将请求与实现解耦并封装成独立对象，从而使不同的请求对客户端的实现参数化：将创建模块的逻辑封装在一个对象里，这个对象提供一个参数化的请求接口，通过调用这个接口并传递一些参数实现调用命令对象内部中的一些方法

其实就是将方法进行封装管理，比如canvas有填充颜色、绘制线条等功能，我们可以将这些方法封装在一个对象中，只抛出简单易懂的命令提供使用

### 八、访问者模式
访问者模式针对于对象结构中的元素，定义在不改变该对象的前提下访问结构中元素的新方法

比如在低版本ie中，dom事件中的this并不是指向该dom而是window，可以通过另外一种方式实现：
```javascript
function bindIEEvent (dom, type, fn, data) {
    dom.attachEvent('on' + type, function(e) {
        fn.call(dom, e, data || {})
    })
}
```
这样就可以与其他浏览器保持一样的回调方法了

将操作方法独立于数据，使其可以自由化演变。所以访问者模式更适合于数据稳定，但是数据的操作环境易变的环境下。当环境发生变化时，可以改操作方法以适应操作环境而不用修改原数据

### 九、中介者模式
通过中介者对象封装一系列对象之间的交互，使对象之间不再相互引用，降低他们之间的耦合，改变之间的交互

中介者与观察者：他们都是通过消息的收发机制实现的，在观察者模式中，一个对象既可以是消息的发送者也可以是消息的接收者，他们之间信息交流依托于消息系统实现的解耦。而中介者模式中信息的发送者只有一个，就是中介者对象，而且中介者对象不能订阅信息，只有活跃对象才可以订阅中介者的消息

中介者实现代码同观察者，只是调用思维不同

### 十、备忘录模式
备忘录模式是在不破坏对象的封装性的前提下，在对象之外捕获并保存该对象内部的状态以便之后对象使用或对象恢复状态

比如在表格的上一页下一页功能中，当点击了下一页的时候，可以先将当前数据保存起来后再请求，如果点上一页的话，就不需要重复请求了

通过对数据的缓存，减少服务器的压力

### 十一、迭代器模式
在不暴露对象内部结构的同时，可以顺序地访问聚合对象内部的元素

优化循环操作的实现，简化代码，使得代码清晰紧凑

### 十二、解释器模式
对一种语言给出其文法表示形式，并定义一种解释器，通过使用这种解释器来解释语言中定义的句子

处理特定的语法逻辑规则，生成对应的结果

### 十三、总结
行为型设计模式主要是对逻辑的一些总结使用，从而改进模块之间的交流与耦合

其中观察者模式、状态模式、策略模式、职责链模式在开发中会经常用到，能较好地提高代码质量与清晰度
